// 修正版のコード例

// グローバル変数
let currentUserId = null;
let isCleaningUp = false;

// 1. 認証状態変更時の修正版
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    await signInAnonymously(auth);
    return;
  }

  if (sceneStarted) return;
  
  currentUserId = user.uid;
  
  // 🔧 修正点1: 既存セッションを必ずクリーンアップ
  await cleanupExistingSession(user.uid);
  
  // その後でonDisconnectを設定
  const hostSnap = await get(ref(db, `rooms/${roomCode}/host`));
  const hostUID = hostSnap.exists() ? hostSnap.val() : null;

  if (user.uid === hostUID) {
    await onDisconnect(ref(db, `rooms/${roomCode}`)).remove();
  } else {
    await onDisconnect(ref(db, `rooms/${roomCode}/players/${user.uid}`)).remove();
  }

  sceneStarted = true;
  startSceneFlow();
});

// 🔧 新規追加: 既存セッションクリーンアップ関数
async function cleanupExistingSession(uid) {
  try {
    console.log("🧹 既存セッションをクリーンアップ中...");
    
    // 1. プレイヤー情報の削除
    const playerRef = ref(db, `rooms/${roomCode}/players/${uid}`);
    const playerSnap = await get(playerRef);
    if (playerSnap.exists()) {
      await set(playerRef, null);
      console.log("👤 既存プレイヤー情報を削除しました");
    }

    // 2. シグナリング情報の削除
    const signalRef = ref(db, `rooms/${roomCode}/signals/${uid}`);
    const signalSnap = await get(signalRef);
    if (signalSnap.exists()) {
      await set(signalRef, null);
      console.log("📡 既存シグナリング情報を削除しました");
    }

    // 3. 他のプレイヤーからのシグナリング情報も削除
    const allSignalsSnap = await get(ref(db, `rooms/${roomCode}/signals`));
    if (allSignalsSnap.exists()) {
      const allSignals = allSignalsSnap.val();
      for (const [fromUID, toMap] of Object.entries(allSignals)) {
        if (toMap && toMap[uid]) {
          await set(ref(db, `rooms/${roomCode}/signals/${fromUID}/${uid}`), null);
          console.log(`📡 ${fromUID}からのシグナリング情報を削除しました`);
        }
      }
    }

    // 4. 少し待機（Firebase側の反映待ち）
    await new Promise(resolve => setTimeout(resolve, 1000));
    
  } catch (error) {
    console.error("セッションクリーンアップエラー:", error);
  }
}

// 🔧 修正点2: WebRTC接続のクリーンアップ
async function cleanupWebRTCConnections() {
  try {
    console.log("🔌 WebRTC接続をクリーンアップ中...");
    
    // 既存のPeerConnection接続をすべて閉じる
    for (const [uid, pc] of Object.entries(peerConnections)) {
      if (pc) {
        pc.close();
        console.log(`🔌 ${uid}への接続を閉じました`);
      }
    }
    
    // PeerConnectionsをクリア
    Object.keys(peerConnections).forEach(key => {
      delete peerConnections[key];
    });

    // ローカルストリームを停止
    if (localStream) {
      localStream.getTracks().forEach(track => {
        track.stop();
        console.log("📷 カメラトラックを停止しました");
      });
      localStream = null;
    }

    // ビデオ要素をすべて削除
    const videoGrid = document.getElementById("videoGrid");
    if (videoGrid) {
      videoGrid.innerHTML = "";
      console.log("📺 ビデオ要素をクリアしました");
    }
    
  } catch (error) {
    console.error("WebRTCクリーンアップエラー:", error);
  }
}

// 🔧 修正点3: ページ離脱処理の改善
let isPageUnloading = false;

// beforeunloadイベント - ページが閉じられる直前
window.addEventListener("beforeunload", async (event) => {
  isPageUnloading = true;
  await gracefulShutdown();
});

// visibilitychangeは警告のみに変更
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden" && !isPageUnloading) {
    console.warn("⚠️ ページが非表示になりました（タブ切り替えなど）");
    // 強制的にページ移動はしない
    
    // 必要に応じて一時停止処理
    if (timerInterval) {
      clearInterval(timerInterval);
      console.log("⏸️ タイマーを一時停止しました");
    }
  } else if (document.visibilityState === "visible") {
    console.log("👁️ ページが再表示されました");
    
    // タイマー再開処理
    if (timerStarted && !timerInterval && remainingSeconds > 0) {
      startCountdown();
      console.log("▶️ タイマーを再開しました");
    }
  }
});

// 🔧 新規追加: 適切な終了処理
async function gracefulShutdown() {
  if (isCleaningUp) return;
  isCleaningUp = true;
  
  try {
    console.log("🏁 アプリケーション終了処理を開始...");
    
    // 1. WebRTC接続のクリーンアップ
    await cleanupWebRTCConnections();
    
    // 2. Firebase接続のクリーンアップ
    if (currentUserId) {
      await cleanupExistingSession(currentUserId);
    }
    
    // 3. タイマーの停止
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    
    console.log("✅ 終了処理完了");
    
  } catch (error) {
    console.error("終了処理エラー:", error);
  }
}

// 🔧 修正点4: WebRTC接続開始前のクリーンアップ
async function startCameraAndConnect() {
  try {
    // 開始前に既存の接続をクリーンアップ
    await cleanupWebRTCConnections();
    
    localStream = await navigator.mediaDevices.getUserMedia({ 
      video: true, 
      audio: false 
    });

    const video = document.createElement("video");
    video.srcObject = localStream;
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
    video.style.width = "200px";
    video.style.height = "150px";
    video.style.margin = "10px";
    document.getElementById("videoGrid").appendChild(video);
    
    await video.play().catch(e => console.warn("ローカル再生エラー:", e));
    console.log("📷 ローカルカメラ取得完了");

    // Firebase側の状態更新
    await set(ref(db, `rooms/${roomCode}/players/${auth.currentUser.uid}/cameraReady`), true);

    // 他のプレイヤーとの接続開始
    const playersSnap = await get(ref(db, `rooms/${roomCode}/players`));
    const players = playersSnap.val();

    for (const uid in players) {
      if (uid !== auth.currentUser.uid) {
        console.log("🛰️ 接続開始 to:", uid);
        await createConnectionWith(uid);
      }
    }

    listenForSignals();
    
  } catch (err) {
    console.error("カメラ取得エラー:", err);
    alert("カメラの許可が必要です。ページを更新して再試行してください。");
  }
}

// 🔧 修正点5: エラーハンドリングの強化
async function createConnectionWith(remoteUID) {
  try {
    // 既存の接続があれば閉じる
    if (peerConnections[remoteUID]) {
      peerConnections[remoteUID].close();
      delete peerConnections[remoteUID];
    }

    const pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    // 接続状態の監視
    pc.onconnectionstatechange = () => {
      console.log(`🔗 ${remoteUID}との接続状態: ${pc.connectionState}`);
      
      if (pc.connectionState === 'failed') {
        console.warn(`❌ ${remoteUID}との接続に失敗しました`);
        // 必要に応じて再接続処理
      }
    };

    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });

    pc.ontrack = (event) => {
      console.log("🎥 映像を受信 from", remoteUID);
      
      // 既存のビデオ要素があれば削除
      const existingVideo = document.querySelector(`[data-user-id="${remoteUID}"]`);
      if (existingVideo) {
        existingVideo.remove();
      }
      
      const remoteVideo = document.createElement("video");
      remoteVideo.setAttribute("data-user-id", remoteUID);
      remoteVideo.srcObject = event.streams[0];
      remoteVideo.autoplay = true;
      remoteVideo.playsInline = true;
      remoteVideo.style.width = "200px";
      remoteVideo.style.height = "150px";
      remoteVideo.style.margin = "10px";
      
      document.getElementById("videoGrid").appendChild(remoteVideo);
      remoteVideo.play().catch(e => console.warn("再生エラー:", e));
    };

    pc.onicecandidate = (event) => {
      if (event.candidate) {
        console.log("❄ ICE candidate 送信 to:", remoteUID);
        const signalRef = ref(db, `rooms/${roomCode}/signals/${auth.currentUser.uid}/${remoteUID}/candidates`);
        const newRef = push(signalRef);
        set(newRef, event.candidate);
      }
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    await set(ref(db, `rooms/${roomCode}/signals/${auth.currentUser.uid}/${remoteUID}/offer`), {
      type: offer.type,
      sdp: offer.sdp
    });

    peerConnections[remoteUID] = pc;
    console.log("📡 Offer 送信完了 to:", remoteUID);
    
  } catch (error) {
    console.error(`${remoteUID}との接続作成エラー:`, error);
  }
}
